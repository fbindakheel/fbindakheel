<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Pixel Platformer (Revised Fix)</title>
    <style>
        body { margin: 0; padding: 0; background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e); display: flex; justify-content: center; align-items: center; min-height: 100vh; font-family: 'Courier New', monospace; overflow: hidden; }
        #gameContainer { text-align: center; background: rgba(0, 0, 0, 0.9); padding: 20px; border-radius: 15px; box-shadow: 0 0 50px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(255, 255, 255, 0.1); border: 2px solid rgba(0, 255, 255, 0.3); }
        canvas { border: 3px solid #00ffff; border-radius: 8px; image-rendering: pixelated; background: linear-gradient(to bottom, #4facfe 0%, #00f2fe 40%, #43e97b 60%, #38f9d7 100%); box-shadow: 0 0 30px rgba(0, 255, 255, 0.3); }
        .ui { color: #00ffff; margin: 15px 0; font-size: 20px; text-shadow: 0 0 15px rgba(0, 255, 255, 0.8); font-weight: bold; }
        .controls { color: #ffffff; font-size: 14px; margin: 15px 0; opacity: 0.9; line-height: 1.6; }
        .enemy-info { color: #ffffff; font-size: 12px; margin: 10px 0; text-align: left; display: inline-block; background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 8px; }
        button { background: linear-gradient(45deg, #ff6b6b, #ee5a24, #fd79a8); color: white; border: none; padding: 12px 24px; font-size: 16px; border-radius: 8px; cursor: pointer; margin: 8px; font-family: 'Courier New', monospace; font-weight: bold; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4); transition: all 0.3s ease; text-transform: uppercase; }
        button:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5); background: linear-gradient(45deg, #fd79a8, #ff6b6b, #ee5a24); }
        button:active { transform: translateY(-1px); }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="ui"> Lives: <span id="lives">3</span> | Level: <span id="level">1</span> | Score: <span id="score">0</span> </div>
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        <div class="controls"> <strong>CONTROLS:</strong> Arrow Keys or WASD to move â€¢ Space/Up to jump </div>
        <div class="enemy-info"> <strong>ENEMIES:</strong><br> ðŸ”´ Red Chaser - Smart AI that hunts you down<br> ðŸŸ  Orange Shooter - Fires deadly projectiles<br> ðŸŸ£ Purple Spiker - Instant death on contact<br> ðŸ”µ Blue Jumper - Leaps across platforms to reach you </div>
        <div> <button onclick="generateNewLevelButton()">ðŸŽ² New Level</button> <button onclick="resetGame()">ðŸ”„ Reset Game</button> </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = { lives: 3, level: 1, score: 0, gameOver: false, won: false, camera: { x: 0, y: 0 } };
        const player = { x: 100, y: 450, width: 20, height: 20, velX: 0, velY: 0, speed: 1, maxSpeed: 2.5, jumpPower: 20, onGround: false, acceleration: 0.1, friction: 0.82, color: '#ff3742', facing: 1, animFrame: 0, invulnerable: 0 };
        
        let platforms = [], enemies = [], projectiles = [], particles = [], collectibles = [], flag = null;
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; if (e.key === ' ') e.preventDefault(); });
        document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        
        class Platform { /* ... No changes from previous response ... */ 
            constructor(x, y, width, height, type = 'normal') { this.x = x; this.y = y; this.width = width; this.height = height; this.type = type; this.originalX = x; this.moveSpeed = 1 + Math.random(); this.moveRange = 80 + Math.random() * 60; this.direction = Math.random() > 0.5 ? 1 : -1; this.color = this.getColor(); this.isCrumbling = false; this.crumbleTimer = null; }
            getColor() { switch(this.type) { case 'moving': return '#6c5ce7'; case 'crumbling': return '#fd79a8'; case 'ice': return '#74b9ff'; default: return '#2d3436'; } }
            update() { if (this.type === 'moving') { this.x += this.moveSpeed * this.direction; if (Math.abs(this.x - this.originalX) > this.moveRange) { this.direction *= -1; this.x = this.originalX + this.moveRange * this.direction; } } }
            startCrumble() { if (this.type === 'crumbling' && !this.isCrumbling) { this.isCrumbling = true; this.color = 'rgba(253, 121, 168, 0.5)'; this.crumbleTimer = setTimeout(() => { const index = platforms.indexOf(this); if (index > -1) { for(let i = 0; i < 20; i++) { particles.push(new Particle(this.x + Math.random()*this.width, this.y + Math.random()*this.height, '#fd79a8')); } platforms.splice(index, 1); } }, 300); } }
            draw() { ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; ctx.fillRect(this.x + 3, this.y + 3, this.width, this.height); ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); const surfaceColor = this.type === 'moving' ? '#a29bfe' : this.type === 'ice' ? '#81ecec' : this.type === 'crumbling' && this.isCrumbling ? 'rgba(253,121,168,0.2)' : this.type === 'crumbling' ? '#fab1a0' : '#00b894'; ctx.fillStyle = surfaceColor; ctx.fillRect(this.x, this.y, this.width, 6); ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; ctx.fillRect(this.x + 2, this.y + 2, this.width - 4, 3); if (this.type === 'ice') { ctx.fillStyle = 'rgba(255,255,255,0.6)'; for(let i=0;i<this.width; i+=10) ctx.fillRect(this.x+i, this.y+1,2,1); } }
        }
        
        class Enemy {
            constructor(x, y, type) { /* ... constructor same ... */ 
                this.x = x; this.y = y; this.startX = x; this.startY = y; this.width = 18; this.height = 18; this.type = type; this.velX = 0; this.velY = 0; this.onGround = false; this.health = 1; this.lastAction = 0; this.detectionRange = 250; this.state = 'patrol'; this.patrolDirection = Math.random() > 0.5 ? 1 : -1; this.animFrame = Math.random() * 10;
                this.setupByType();
            }
            setupByType() { /* ... same as before ... */ 
                switch(this.type) {
                    case 'chaser': this.color = '#e74c3c'; this.speed = 1.8; this.jumpPower = 10; this.aggressiveness = 0.8; break;
                    case 'shooter': this.color = '#f39c12'; this.speed = 1.2; this.shootCooldown = 1800; this.range = 300; break;
                    case 'spiker': this.color = '#8e44ad'; this.speed = 0.8; this.deadly = true; this.spikes = []; for(let i = 0; i < 6; i++) { this.spikes.push({ offset: i * 3, height: 3 + Math.random() * 2 }); } break;
                    case 'jumper': this.color = '#3498db'; this.speed = 1.5; this.jumpPower = 15; this.jumpCooldown = 2000; this.detectionRange = 180; break;
                }
            }
            distanceToPlayer() { const dx = player.x - this.x; const dy = player.y - this.y; return Math.sqrt(dx * dx + dy * dy); }
            canSeePlayer() { const d = this.distanceToPlayer(); const hDiff = Math.abs(player.y - this.y); return d < this.detectionRange && hDiff < 100 && !gameState.gameOver; } // Added !gameState.gameOver
            
            update() {
                this.animFrame += 0.1;
                this.velY += 0.5; // Apply gravity
                if (this.velY > 12) this.velY = 12; // Terminal velocity

                if (this.canSeePlayer()) {
                    this.state = 'hunting'; this.executeHuntingBehavior();
                } else {
                    this.state = 'patrol'; this.executePatrolBehavior();
                }
                
                this.handlePlatformCollisions(); // Applies velocities and resolves collisions

                // Apply friction AFTER collision resolution
                if (this.onGround) { // Stronger friction on ground
                    this.velX *= 0.90;
                } else { // Less friction in air
                    this.velX *= 0.97;
                }
                if (Math.abs(this.velX) < 0.05) this.velX = 0; // Snap to stop if very slow
                
                // Boundary checks
                if (this.x < 0) { this.x = 0; this.velX = 0; if(this.state === 'patrol') this.patrolDirection = 1; }
                if (this.x + this.width > canvas.width) { this.x = canvas.width - this.width; this.velX = 0; if(this.state === 'patrol') this.patrolDirection = -1; }
                if (this.y > canvas.height + 50) { this.respawn(); }
            }

            handlePlatformCollisions() {
                // --- Horizontal Collision ---
                this.x += this.velX;
                for (let p of platforms) {
                    if (this.checkCollision(p)) {
                        if (this.velX > 0) { // Moving Right, hit left side of platform
                            this.x = p.x - this.width;
                        } else if (this.velX < 0) { // Moving Left, hit right side of platform
                            this.x = p.x + p.width;
                        }
                        if (this.state === 'patrol') { this.patrolDirection *= -1; } // Always flip patrol if hit wall
                        this.velX = 0; // Stop horizontal movement
                    }
                }

                // --- Vertical Collision ---
                this.y += this.velY;
                this.onGround = false; // Assume not on ground until collision confirms
                for (let p of platforms) {
                    if (this.checkCollision(p)) { // Check collision with current (new) Y
                        if (this.velY > 0) { // Moving Down, landing on top of platform
                            this.y = p.y - this.height;
                            this.velY = 0;
                            this.onGround = true;
                            if (p.type === 'moving') { // Stick to moving platform
                                this.x += p.moveSpeed * p.direction;
                            }
                        } else if (this.velY < 0) { // Moving Up, hitting bottom of platform
                            this.y = p.y + p.height;
                            this.velY = 0;
                        }
                    }
                }
            }

            executePatrolBehavior() {
                if (this.onGround) {
                    let groundAhead = false;
                    // Check slightly in front and below the direction of movement
                    const lookDist = this.width * 0.6; // How far to look ahead from center
                    const checkX = this.x + this.width / 2 + (this.patrolDirection * lookDist);
                    const checkY = this.y + this.height + 1; // 1px below feet

                    for (let p of platforms) {
                        if (checkX >= p.x && checkX <= p.x + p.width && // Is the checkX point within platform's X bounds?
                            checkY >= p.y && checkY <= p.y + p.height + 10) { // Is the checkY point on or slightly above platform's surface?
                            groundAhead = true;
                            break;
                        }
                    }
                    if (!groundAhead) { // No ground detected ahead
                        this.patrolDirection *= -1;
                        this.velX = 0; // Stop before potentially falling
                    }
                }
                // If on ground or has a reason to move (e.g. not blocked by cliff)
                if(this.velX === 0 && this.onGround) { // Only add patrol velocity if not already stopped by cliff or wall
                     this.velX += this.patrolDirection * this.speed * 0.15;
                } else if (this.onGround) {
                    // Maintain some patrol speed if already moving
                    this.velX = this.patrolDirection * this.speed * 0.15;
                }


                // Clamp patrol speed
                const maxPatrolSpeed = this.speed * 0.5;
                if (this.velX > maxPatrolSpeed) this.velX = maxPatrolSpeed;
                if (this.velX < -maxPatrolSpeed) this.velX = -maxPatrolSpeed;

                // Turn around at level-defined patrol limits (originalX based)
                if (this.onGround && (this.x <= this.startX - 60 || this.x >= this.startX + 60 )) {
                     if((this.x <= this.startX - 60 && this.patrolDirection === -1) || (this.x >= this.startX + 60 && this.patrolDirection === 1)) {
                        this.patrolDirection *= -1;
                     }
                }
                if (this.onGround && Math.random() < 0.008 && this.type !== 'spiker') { this.velY = -this.jumpPower * 0.4; } // Occasional small hop
            }
            executeHuntingBehavior() { /* ... No major changes, relies on onGround & vel set by AI funcs ... */ 
                const dx = player.x - this.x; const dy = player.y - this.y; const distance = this.distanceToPlayer();
                switch(this.type) {
                    case 'chaser': this.chasePlayer(dx, dy, distance); break;
                    case 'shooter': this.shootAtPlayer(dx, dy, distance); break;
                    case 'spiker': this.rushPlayer(dx, dy); break;
                    case 'jumper': this.jumpAtPlayer(dx, dy, distance); break;
                }
            }
            chasePlayer(dx, dy, distance) { /* ... No major changes ... */ 
                const moveForce = this.speed * 0.05; 
                if (Math.abs(dx) > 10) { this.velX += (dx > 0 ? moveForce : -moveForce); }
                else {this.velX *= 0.8;} 
                if (this.onGround && dy < -30 && Math.abs(dx) < 120 && Math.random() < 0.04) { this.velY = -this.jumpPower; }
                if (this.onGround && Math.abs(this.velX) < 0.5 && Math.abs(dx) > 15 && Math.random() < 0.06) { this.velY = -this.jumpPower * 0.7; }
                const maxChaseSpeed = this.speed;
                if (this.velX > maxChaseSpeed) this.velX = maxChaseSpeed; if (this.velX < -maxChaseSpeed) this.velX = -maxChaseSpeed;
            }
            shootAtPlayer(dx, dy, distance) { /* ... No major changes ... */ 
                const now = Date.now();
                if (distance < 100) { this.velX += (dx > 0 ? -0.4 : 0.4) * this.speed * 0.1; } 
                else if (distance > 180 && distance < this.range) { this.velX += (dx > 0 ? 0.3 : -0.3) * this.speed * 0.1; }
                else { this.velX *= 0.7; }
                if (now - this.lastAction > this.shootCooldown && distance < this.range && Math.abs(dy) < 60) { this.fireProjectile(dx, dy, distance); this.lastAction = now; }
            }
            rushPlayer(dx, dy) { /* ... No major changes ... */ 
                const rushForce = this.speed * 0.12; this.velX += (dx > 0 ? rushForce : -rushForce);
                if (this.onGround && dy < -15 && Math.abs(dx) < 90 && Math.random() < 0.05) { this.velY = -10; }
                const maxRushSpeed = this.speed * 1.2;
                if (this.velX > maxRushSpeed) this.velX = maxRushSpeed; if (this.velX < -maxRushSpeed) this.velX = -maxRushSpeed;
            }
            jumpAtPlayer(dx, dy, distance) { /* ... No major changes ... */
                 const now = Date.now();
                if (this.onGround && now - this.lastAction > this.jumpCooldown && distance < this.detectionRange && dy < 30 && Math.abs(dx) > 5) {
                    let jumpVelXTarget = (dx / (distance || 1)) * this.speed * 1.1; 
                    let jumpVelYTarget = -this.jumpPower * (dy < -40 ? 1.3 : 1); 
                    this.velX = jumpVelXTarget; this.velY = jumpVelYTarget; this.lastAction = now; this.createJumpParticles();
                } else if (this.onGround) { 
                     if (Math.abs(dx) > 20) { this.velX += (dx > 0 ? 0.25 : -0.25) * this.speed * 0.1; } 
                     else { this.velX *= 0.6; }
                }
             }
            fireProjectile(dx, dy, distance) { /* ... No major changes ... */ 
                const projSpeed = 4.5; 
                const predictedPlayerX = player.x + player.velX * (distance / projSpeed) * 0.2; 
                const predictedPlayerY = player.y + player.velY * (distance / projSpeed) * 0.2;
                const pDx = predictedPlayerX - (this.x + this.width/2); const pDy = predictedPlayerY - (this.y + this.height/2);
                const pDist = Math.sqrt(pDx*pDx + pDy*pDy) || 1;
                const velX = (pDx / pDist) * projSpeed; const velY = (pDy / pDist) * projSpeed;
                projectiles.push(new Projectile(this.x + this.width/2 - 3, this.y + this.height/2 - 3, velX, velY, 'enemy'));
                for (let i = 0; i < 5; i++) { particles.push(new Particle(this.x + this.width/2 + velX*1.5, this.y + this.height/2 + velY*1.5, '#ff6b35')); }
            }
            createJumpParticles() { /* ... same ... */ }
            checkCollision(rect) { return this.x < rect.x + rect.width && this.x + this.width > rect.x && this.y < rect.y + rect.height && this.y + this.height > rect.y; }
            respawn() { this.x = this.startX; this.y = this.startY - 20; this.velX = 0; this.velY = 0; this.state = 'patrol'; this.health = 1; this.onGround = false;} // Ensure onGround is false on respawn
            draw() { /* ... Previous drawing code for shadow, body ... */ 
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; ctx.beginPath(); ctx.ellipse(this.x + this.width / 2, this.y + this.height + 2, this.width / 2 * 0.8, 3, 0, 0, Math.PI * 2); ctx.fill();
                const bounce = this.onGround ? Math.sin(this.animFrame * 0.5) * 1 : 0; const bodyY = this.y + bounce;
                ctx.fillStyle = this.color; ctx.fillRect(this.x, bodyY, this.width, this.height);
                ctx.fillStyle = '#ffffff'; const eyeSize = 2; const eyeYVal = bodyY + this.height * 0.25;
                
                // Determine facing direction more consistently for drawing
                let facingRight;
                if (this.state === 'hunting') {
                    facingRight = player.x > this.x;
                } else { // Patrol
                    facingRight = this.patrolDirection > 0;
                    if (Math.abs(this.velX) < 0.1 && this.velX !== 0) { // If moving very slowly but not stopped, use velX direction
                        facingRight = this.velX > 0;
                    }
                }


                switch(this.type) {
                    case 'chaser': /* ... chaser draw (ensure facingRight is used) ... */ 
                        const eyeX1Chaser = facingRight ? this.x + this.width * 0.6 : this.x + this.width * 0.2;
                        const eyeX2Chaser = facingRight ? this.x + this.width * 0.25 : this.x + this.width * 0.55;
                        ctx.fillRect(eyeX1Chaser, eyeYVal, eyeSize + 1, eyeSize + 1);
                        ctx.fillRect(eyeX2Chaser, eyeYVal, eyeSize + 1, eyeSize + 1);
                        ctx.fillStyle = '#ffffff'; ctx.fillRect(this.x + 5, bodyY + 12, 8, 3);
                        ctx.fillStyle = this.color; ctx.fillRect(this.x + 6, bodyY + 13, 2, 2); ctx.fillRect(this.x + 10, bodyY + 13, 2, 2);
                        break;
                    case 'shooter':
                        ctx.fillStyle = '#2c3e50'; const barrelY = bodyY + this.height * 0.4; const barrelWidth = 8;
                        const barrelX = facingRight ? this.x + this.width : this.x - barrelWidth;
                        ctx.fillRect(barrelX, barrelY, barrelWidth, 4);
                        
                        ctx.fillStyle = '#ffffff'; // Eyes for shooter
                        const shooterEyeYPos = eyeYVal - 1;
                        const eye1RelX_shooter = this.width * 0.60; 
                        const eye2RelX_shooter = this.width * 0.25;
                        if (facingRight) {
                            ctx.fillRect(this.x + eye1RelX_shooter, shooterEyeYPos, eyeSize, eyeSize);
                            ctx.fillRect(this.x + eye2RelX_shooter, shooterEyeYPos, eyeSize, eyeSize);
                        } else { // Facing left
                            ctx.fillRect(this.x + (this.width - eye1RelX_shooter) - eyeSize, shooterEyeYPos, eyeSize, eyeSize);
                            ctx.fillRect(this.x + (this.width - eye2RelX_shooter) - eyeSize, shooterEyeYPos, eyeSize, eyeSize);
                        }
                        ctx.fillStyle = Date.now() - this.lastAction < this.shootCooldown ? (Math.floor(Date.now()/100)%2 ? '#e74c3c' : '#ff8c6c' ) : '#2ecc71';
                        ctx.fillRect(this.x + 2, bodyY - 3, this.width - 4, 2);
                        break;
                    case 'spiker': /* ... spiker draw (ensure facingRight is used for any directional details if added) ... */ 
                        ctx.fillStyle = '#ffffff'; 
                        for (let spike of this.spikes) {
                            ctx.fillRect(this.x + spike.offset, bodyY - spike.height + 1, 2, spike.height + 2); 
                            ctx.fillRect(this.x + spike.offset, bodyY + this.height - 2, 2, spike.height); 
                            if (spike.offset < this.width / 2) { 
                                ctx.fillRect(this.x - spike.height + 1, bodyY + spike.offset, spike.height, 2);
                                ctx.fillRect(this.x + this.width -2 , bodyY + spike.offset, spike.height, 2);
                            }
                        }
                        ctx.fillStyle = '#ff0000'; ctx.fillRect(this.x + 4, bodyY + 6, eyeSize, eyeSize); ctx.fillRect(this.x + this.width - 6, bodyY + 6, eyeSize, eyeSize);
                        break;
                    case 'jumper': /* ... jumper draw (ensure facingRight is used) ... */ 
                        ctx.fillStyle = '#bdc3c7'; 
                        for (let i = 0; i < 3; i++) {
                            const coilY = bodyY + this.height * (0.3 + i * 0.2);
                            const coilHeight = this.onGround ? 2 : 1 + Math.abs(Math.sin(this.animFrame)) * 2; 
                            ctx.fillRect(this.x + 3, coilY, this.width - 6, coilHeight);
                        }
                        ctx.fillStyle = '#ffffff';
                        const eyeX1Jumper = facingRight ? this.x + this.width * 0.7 : this.x + this.width * 0.1;
                        const eyeX2Jumper = facingRight ? this.x + this.width * 0.4 : this.x + this.width * 0.4; // This might be an error, should be different for left
                        const eyeX2JumperFixed = facingRight ? this.x + this.width * 0.4 : this.x + this.width * 0.6 - eyeSize;

                        ctx.fillRect(eyeX1Jumper, eyeYVal -2, eyeSize, eyeSize);
                        ctx.fillRect(eyeX2JumperFixed, eyeYVal -2, eyeSize, eyeSize); // Using fixed version
                        if (!this.onGround) { ctx.fillStyle = 'rgba(52, 152, 219, 0.5)'; ctx.fillRect(this.x + this.width/4, this.y + this.height, this.width/2, 4); }
                        break;
                }
                if (this.state === 'hunting') { ctx.fillStyle = '#ff0000'; ctx.font = '15px monospace'; ctx.fillText('!', this.x + this.width / 2 - 3, this.y - 5); }
            }
        }
        
        class Projectile { /* ... No changes ... */ 
            constructor(x, y, velX, velY, owner = 'enemy') { this.x = x; this.y = y; this.velX = velX; this.velY = velY; this.owner = owner; this.width = 6; this.height = 6; this.life = 180; this.trail = []; this.color = owner === 'enemy' ? '#e74c3c' : '#3498db'; }
            update() { this.trail.push({ x: this.x, y: this.y, w: this.width, h:this.height }); if (this.trail.length > 8) this.trail.shift(); this.x += this.velX; this.y += this.velY; this.velY += 0.05; this.life--; if (this.owner === 'enemy' && this.checkCollision(player) && player.invulnerable <= 0) { this.createImpactEffect(); loseLife(); return false; } for (let platform of platforms) { if (this.checkCollision(platform)) { this.createImpactEffect(platform.color); return false; } } return this.life > 0 && this.x > -this.width && this.x < canvas.width && this.y > -this.height && this.y < canvas.height; }
            checkCollision(rect) { return this.x < rect.x + rect.width && this.x + this.width > rect.x && this.y < rect.y + rect.height && this.y + this.height > rect.y; }
            createImpactEffect(color = '#ff6b35') { for (let i = 0; i < 6; i++) { particles.push(new Particle(this.x + this.width/2, this.y + this.height/2, color, {size: 4})); } }
            draw() { for (let i = 0; i < this.trail.length; i++) { const point = this.trail[i]; const alpha = (i / this.trail.length) * 0.5; ctx.globalAlpha = alpha; ctx.fillStyle = this.color; ctx.fillRect(point.x + (this.width - point.w)/2, point.y + (this.height - point.h)/2 , point.w * (i/this.trail.length), point.h * (i/this.trail.length)); } ctx.globalAlpha = 1; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.fillRect(this.x + 1, this.y + 1, this.width - 2, this.height - 2); }
        }
        class Particle { /* ... No changes ... */ 
            constructor(x, y, color = '#ffffff', options = {}) { this.x = x + (Math.random() - 0.5) * (options.spread || 10); this.y = y + (Math.random() - 0.5) * (options.spread || 10); this.velX = (Math.random() - 0.5) * (options.speedX || 6); this.velY = (Math.random() - 0.5) * (options.speedY || 6) + (options.vyBase || -2); this.color = color; this.life = (options.life || 40) + Math.random() * 20; this.maxLife = this.life; this.size = (options.size || 2) + Math.random() * 3; this.gravity = options.gravity || 0.2; this.friction = options.friction || 0.98; }
            update() { this.x += this.velX; this.y += this.velY; this.velY += this.gravity; this.velX *= this.friction; this.life--; this.size *= 0.97; return this.life > 0 && this.size > 0.5; }
            draw() { const alpha = Math.max(0, this.life / this.maxLife); ctx.globalAlpha = alpha; ctx.fillStyle = this.color; ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size); ctx.globalAlpha = 1; }
        }
        class Flag { /* ... No changes ... */ 
            constructor(x, y) { this.x = x; this.y = y; this.poleWidth = 10; this.poleHeight = 50; this.flagWidth = 35; this.flagHeight = 22; this.wave = Math.random() * Math.PI * 2; this.sparkles = []; this.glowIntensity = 0; for (let i = 0; i < 5; i++) { this.sparkles.push({ x: Math.random() * this.flagWidth, y: Math.random() * this.flagHeight, phase: Math.random() * Math.PI * 2, speed: 0.05 + Math.random() * 0.05, size: 1 + Math.random() * 1 }); } }
            update() { this.wave += 0.12; this.glowIntensity = Math.sin(this.wave * 0.5) * 0.3 + 0.7; for (let sparkle of this.sparkles) { sparkle.phase += sparkle.speed; } }
            draw() { const poleTopY = this.y - this.poleHeight; ctx.shadowColor = '#00ffaa'; ctx.shadowBlur = 10 * this.glowIntensity; ctx.fillStyle = '#8B4513'; ctx.fillRect(this.x, poleTopY, this.poleWidth, this.poleHeight); ctx.fillStyle = '#CD7F32'; ctx.fillRect(this.x - 1, poleTopY - 3, this.poleWidth + 2, 3); const flagAttachX = this.x + this.poleWidth; const flagAttachY = poleTopY + 5; ctx.beginPath(); ctx.moveTo(flagAttachX, flagAttachY); for (let i = 0; i <= this.flagWidth; i++) { const waveEffect = Math.sin(this.wave + i * 0.2) * 3; ctx.lineTo(flagAttachX + i, flagAttachY + waveEffect + i * 0.1); } ctx.lineTo(flagAttachX + this.flagWidth, flagAttachY + this.flagHeight + Math.sin(this.wave + this.flagWidth * 0.2) * 3 + this.flagWidth * 0.1); for (let i = this.flagWidth; i >= 0; i--) { const waveEffect = Math.sin(this.wave + i * 0.2 - 0.3) * 3; ctx.lineTo(flagAttachX + i, flagAttachY + this.flagHeight + waveEffect + i * 0.1); } ctx.closePath(); ctx.fillStyle = '#00b894'; ctx.fill(); ctx.fillStyle = '#ffeb3b'; const starCenterX = flagAttachX + this.flagWidth * 0.5; const starCenterY = flagAttachY + this.flagHeight * 0.5 + Math.sin(this.wave + this.flagWidth *0.1) * 3; this.drawStar(starCenterX, starCenterY, 5, 8, 4); for (let sparkle of this.sparkles) { const alpha = (Math.sin(sparkle.phase) + 1) * 0.35 * this.glowIntensity; ctx.globalAlpha = Math.max(0, Math.min(1, alpha)); ctx.fillStyle = '#ffeb3b'; const sparkleWaveEffect = Math.sin(this.wave + sparkle.x * 0.2) * 3; ctx.fillRect( flagAttachX + sparkle.x - sparkle.size / 2, flagAttachY + sparkle.y + sparkleWaveEffect + sparkle.x * 0.1 - sparkle.size / 2, sparkle.size, sparkle.size ); } ctx.globalAlpha = 1; ctx.shadowBlur = 0; ctx.shadowColor = 'transparent'; }
            drawStar(cx,cy,spikes,outerRadius,innerRadius){let rot=Math.PI/2*3;let x=cx;let y=cy;const step=Math.PI/spikes;ctx.beginPath();ctx.moveTo(cx,cy-outerRadius);for(let i=0;i<spikes;i++){x=cx+Math.cos(rot)*outerRadius;y=cy+Math.sin(rot)*outerRadius;ctx.lineTo(x,y);rot+=step;x=cx+Math.cos(rot)*innerRadius;y=cy+Math.sin(rot)*innerRadius;ctx.lineTo(x,y);rot+=step;}ctx.lineTo(cx,cy-outerRadius);ctx.closePath();ctx.fill();}
        }
        
        function updateUI() { document.getElementById('lives').textContent = gameState.lives; document.getElementById('level').textContent = gameState.level; document.getElementById('score').textContent = gameState.score; }
        function loseLife() { if (gameState.gameOver || player.invulnerable > 0) return; player.invulnerable = 120; createPlayerDamageParticles(); gameState.lives--; updateUI(); if (gameState.lives <= 0) { gameState.gameOver = true; gameState.won = false; console.log("Game Over!"); } else { player.x = 100; player.y = canvas.height - 200; player.velX = 0; player.velY = 0; player.onGround = false; } }
        function createPlayerDamageParticles() { for (let i = 0; i < 15; i++) { particles.push(new Particle(player.x + player.width / 2, player.y + player.height / 2, player.color, {speedX: 8, speedY: 8, gravity: 0.3})); } }
        function generatePlatforms() { /* ... No changes ... */ platforms = []; platforms.push(new Platform(0, canvas.height - 40, canvas.width / 2 - 50, 40)); platforms.push(new Platform(canvas.width / 2 + 50, canvas.height - 40, canvas.width / 2 - 50, 40)); platforms.push(new Platform(150, canvas.height - 120, 120, 20)); platforms.push(new Platform(350, canvas.height - 180, 100, 20, 'moving')); platforms.push(new Platform(50, canvas.height - 250, 80, 20, 'ice')); platforms.push(new Platform(550, canvas.height - 280, 100, 20, 'crumbling')); platforms.push(new Platform(750, canvas.height - 150, 150, 20)); platforms.push(new Platform(canvas.width - 200, canvas.height - 350, 130, 20, 'normal'));}
        function generateEnemies() { /* ... No changes ... */ enemies = []; if (gameState.level >= 1) { enemies.push(new Enemy(300, canvas.height - 80, 'chaser')); enemies.push(new Enemy(600, canvas.height - 80, 'shooter')); } if (gameState.level >= 2) { enemies.push(new Enemy(400, canvas.height - 220, 'spiker')); enemies.push(new Enemy(100, canvas.height - 290, 'jumper'));} if (gameState.level >= 3) { enemies.push(new Enemy(canvas.width - 250, canvas.height - 80, 'chaser')); enemies.push(new Enemy(200, canvas.height - 300, 'shooter'));}}
        function generateCollectibles() { /* ... No changes ... */ collectibles = []; const cSpots = [{x:260,y:canvas.height-150},{x:400,y:canvas.height-220},{x:100,y:canvas.height-280},{x:600,y:canvas.height-310},{x:800,y:canvas.height-180}]; cSpots.forEach(s=>{if(Math.random()>0.3)collectibles.push({x:s.x,y:s.y,width:15,height:15,color:'#ffd700',collected:false,score:10*gameState.level,animFrame:Math.random()*Math.PI*2});});}
        function placeFlag() { const fp = platforms.find(p => p.x > canvas.width - 250 && p.y < canvas.height - 300); if (fp) {flag = new Flag(fp.x + fp.width/2-5, fp.y);}else{flag = new Flag(canvas.width-100,canvas.height-40);}}
        function generateNewLevelLogic() { gameState.gameOver=false;gameState.won=false;player.x=100;player.y=canvas.height-200;player.velX=0;player.velY=0;player.onGround=false;player.invulnerable=60;generatePlatforms();generateEnemies();generateCollectibles();placeFlag();projectiles=[];particles=[];updateUI();console.log(`Starting Level ${gameState.level}`);}
        function generateNewLevelButton() { if(gameState.won){gameState.level++;}else if(!gameState.gameOver){/*gameState.lives = Math.min(3, gameState.lives+1);*/}else{resetGame();return;}generateNewLevelLogic();}
        function resetGame() { gameState.lives=3;gameState.level=1;gameState.score=0;gameState.gameOver=false;gameState.won=false;generateNewLevelLogic();console.log("Game Reset!");}

        function updatePlayer() {
            if (gameState.gameOver && !gameState.won) return;

            if (keys['arrowleft'] || keys['a']) { player.velX -= player.acceleration; player.facing = -1; }
            else if (keys['arrowright'] || keys['d']) { player.velX += player.acceleration; player.facing = 1; }
            else { if (player.onGround) player.velX *= player.friction; else player.velX *= 0.97;  if (Math.abs(player.velX) < 0.1) player.velX = 0;} // Adjusted friction

            if (player.velX > player.maxSpeed) player.velX = player.maxSpeed;
            if (player.velX < -player.maxSpeed) player.velX = -player.maxSpeed;

            if ((keys['arrowup'] || keys['w'] || keys[' ']) && player.onGround) { player.velY = -player.jumpPower; player.onGround = false; for (let i=0;i<5;i++){particles.push(new Particle(player.x+player.width/2,player.y+player.height,'#dfe6e9'));}}
            
            player.velY += 0.7; // Gravity
            if (player.velY > 15) player.velY = 15; // Terminal velocity

            let onIcePlatform = false;

            // Horizontal Collision
            player.x += player.velX;
            for (let p of platforms) {
                if (player.x < p.x + p.width && player.x + player.width > p.x && player.y < p.y + p.height && player.y + player.height > p.y) {
                    if (player.velX > 0) { player.x = p.x - player.width; }
                    else if (player.velX < 0) { player.x = p.x + p.width; }
                    player.velX = 0;
                }
            }

            // Vertical Collision
            player.y += player.velY;
            player.onGround = false; 
            for (let p of platforms) {
                if (player.x < p.x + p.width && player.x + player.width > p.x && player.y < p.y + p.height && player.y + player.height > p.y) {
                    if (player.velY > 0) { 
                        player.y = p.y - player.height; player.velY = 0; player.onGround = true;
                        if (p.type === 'moving') { player.x += p.moveSpeed * p.direction; }
                        if (p.type === 'ice') { onIcePlatform = true; }
                        if (p.type === 'crumbling') { p.startCrumble(); }
                    } else if (player.velY < 0) { 
                        player.y = p.y + p.height; player.velY = 0;
                    }
                }
            }
            
            if(onIcePlatform && player.onGround) { if(!(keys['arrowleft']||keys['a']||keys['arrowright']||keys['d'])) player.velX *= 0.96; } // Slipperiness when no input on ice
            else if (player.onGround && !(keys['arrowleft']||keys['a']||keys['arrowright']||keys['d'])) { player.velX *= (player.friction * 0.8); } // Normal ground friction
            
            if (player.x < 0) player.x = 0; if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y > canvas.height + player.height) { loseLife(); }
            if (player.invulnerable > 0) player.invulnerable--;
            if (!player.onGround) { player.animFrame = 2; } else if (Math.abs(player.velX)>0.1) { player.animFrame=(player.animFrame+0.2)%2; } else { player.animFrame = 0.5 + Math.sin(Date.now()*0.005)*0.4; }
        }

        function drawPlayer() { /* ... No changes ... */ if (player.invulnerable > 0 && Math.floor(player.invulnerable / 6) % 2 === 0) { return; } ctx.fillStyle = player.color; let drawX = player.x; let drawY = player.y; let dWidth = player.width; let dHeight = player.height; if (player.animFrame === 2) { dHeight = player.height + 3; dWidth = player.width - 3; drawX = player.x + 1.5; drawY = player.y - 1.5; } else if (player.animFrame < 2 && player.onGround && Math.abs(player.velX) > 0.1) { dHeight = player.height - Math.abs(Math.sin(Date.now() * 0.02)) * 3; drawY = player.y + (player.height - dHeight); } else if (player.animFrame < 2 && player.onGround) { dHeight = player.height - (player.animFrame - 0.5) * 4; drawY = player.y + (player.height - dHeight)/2; } ctx.fillRect(drawX, drawY, dWidth, dHeight); ctx.fillStyle = 'white'; const eyeY = drawY + dHeight * 0.25; const eyeSize = 3; if (player.facing > 0) { ctx.fillRect(drawX + dWidth * 0.6, eyeY, eyeSize, eyeSize); } else { ctx.fillRect(drawX + dWidth * 0.2, eyeY, eyeSize, eyeSize); } ctx.fillStyle = 'black'; if (player.facing > 0) { ctx.fillRect(drawX + dWidth * 0.6 + 1, eyeY + 1, eyeSize-2, eyeSize-2); } else { ctx.fillRect(drawX + dWidth * 0.2 + 1, eyeY + 1, eyeSize-2, eyeSize-2); }}
        function updateCollectibles() { /* ... No changes ... */ for (let i = collectibles.length - 1; i >= 0; i--) { const c = collectibles[i]; c.animFrame += 0.05; if (!c.collected && player.x < c.x + c.width && player.x + player.width > c.x && player.y < c.y + c.height && player.y + player.height > c.y) { c.collected = true; gameState.score += c.score; updateUI(); for (let j = 0; j < 10; j++) { particles.push(new Particle(c.x + c.width / 2, c.y + c.height / 2, c.color, {size:5, life: 25})); } collectibles.splice(i, 1); }}}
        function drawCollectibles() { /* ... No changes ... */ for (let c of collectibles) { if (!c.collected) { ctx.fillStyle = c.color; const bounce = Math.sin(c.animFrame) * 4; ctx.beginPath(); ctx.arc(c.x + c.width/2, c.y + c.height/2 + bounce, c.width/2, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; ctx.beginPath(); ctx.arc(c.x + c.width/2 + 2, c.y + c.height/2 + bounce -2, c.width/4, 0, Math.PI*2); ctx.fill(); }}}
        
        function checkEnemyPlayerCollisions() { 
            if (player.invulnerable > 0) return;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                    // Stomp condition: Player is moving down, and player's bottom was above enemy's top in the previous frame (approx).
                    const playerPrevBottom = player.y + player.height - player.velY; // Approximate previous bottom

                    if (player.velY > 0 && playerPrevBottom <= enemy.y + enemy.height/2) { // Adjusted stomp condition slightly
                        enemy.health = 0; 
                        particles.push(...Array(10).fill(null).map(() => new Particle(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color, {vyBase: -5, speedY:3})));
                        player.velY = -player.jumpPower * 0.7; // Good bounce
                        player.onGround = false; 
                        gameState.score += 50 * gameState.level; updateUI();
                    } else { 
                        loseLife(); 
                        player.velX = (player.x + player.width/2 < enemy.x + enemy.width/2 ? -1 : 1) * 7; // Stronger knockback
                        player.velY = -7; 
                        player.onGround = false;
                        break; 
                    }
                }
            }
            enemies = enemies.filter(e => e.health > 0);
        }
        function checkWinCondition() { /* ... No changes ... */ if (!flag || gameState.won || (gameState.gameOver && !gameState.won) ) return; if (player.x < flag.x + flag.poleWidth + flag.flagWidth && player.x + player.width > flag.x && player.y < flag.y && player.y + player.height > flag.y - flag.poleHeight) { gameState.won = true; gameState.score += 100 * gameState.level; updateUI(); console.log(`Level ${gameState.level} Complete!`); for(let i=0; i<50; i++) { particles.push(new Particle(flag.x + flag.poleWidth/2, flag.y - flag.poleHeight, '#FFD700', {spread: 30, speedY: 8, vyBase: -10, life: 80})); } const maxLevels = 3; if (gameState.level >= maxLevels) { console.log("YOU WON THE GAME!"); gameState.gameOver = true; } else { setTimeout(() => { gameState.level++; generateNewLevelLogic(); }, 2000); }}}
        function gameLoop(timestamp) { /* ... No major changes to screen display ... */ 
            const deltaTime = (timestamp - lastTime) || 0; lastTime = timestamp;
            const bgGradient = ctx.createLinearGradient(0,0,0,canvas.height); const timeOfDay = (Date.now() % 20000) / 20000; const c1 = `hsl(${180+timeOfDay*60},70%,60%)`; const c2 = `hsl(${200+timeOfDay*60},80%,70%)`; const c3 = `hsl(${140-timeOfDay*40},60%,50%)`; const c4 = `hsl(${160-timeOfDay*40},70%,60%)`; bgGradient.addColorStop(0,c1);bgGradient.addColorStop(0.4,c2);bgGradient.addColorStop(0.6,c3);bgGradient.addColorStop(1,c4);ctx.fillStyle=bgGradient;ctx.fillRect(0,0,canvas.width,canvas.height);
            if(gameState.gameOver&&gameState.won&&gameState.level>=3){ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.font='bold 48px Courier New';ctx.fillStyle='#00ff00';ctx.textAlign='center';ctx.fillText('ðŸ† YOU WON! ðŸ†',canvas.width/2,canvas.height/2-30);ctx.font='24px Courier New';ctx.fillStyle='#ffffff';ctx.fillText(`Final Score: ${gameState.score}`,canvas.width/2,canvas.height/2+20);ctx.fillText('Press Reset to Play Again',canvas.width/2,canvas.height/2+60);}
            else if(gameState.gameOver&&!gameState.won){ctx.fillStyle='rgba(0,0,0,0.8)';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.font='bold 48px Courier New';ctx.fillStyle='#ff0000';ctx.textAlign='center';ctx.fillText('GAME OVER',canvas.width/2,canvas.height/2-20);ctx.font='24px Courier New';ctx.fillStyle='#ffffff';ctx.fillText('Press Reset to Try Again',canvas.width/2,canvas.height/2+30);}
            else{updatePlayer();platforms.forEach(p=>p.update());enemies.forEach(e=>e.update());projectiles=projectiles.filter(p=>p.update());particles=particles.filter(p=>p.update());if(flag)flag.update();updateCollectibles();checkEnemyPlayerCollisions();if(!gameState.won)checkWinCondition();platforms.forEach(p=>p.draw());particles.forEach(p=>p.draw());drawCollectibles();if(flag)flag.draw();enemies.forEach(e=>e.draw());projectiles.forEach(p=>p.draw());drawPlayer();}
            requestAnimationFrame(gameLoop);
        }
        let lastTime = 0; // Ensure lastTime is initialized for gameLoop
        function init() { resetGame(); requestAnimationFrame(gameLoop); }
        init();
    </script>
</body>
</html>
